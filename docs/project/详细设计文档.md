# Claude-Mem 详细设计文档

> 版本：v9.1.1 | 更新日期：2026-02-08

---

## 1. 模块详细设计

### 1.1 Hook 处理模块

#### 1.1.1 Context Handler（上下文注入）

**文件**：`src/cli/handlers/context.ts`

**职责**：SessionStart 时注入历史上下文到 Claude Code 会话。

**设计**：

```
输入：无（自动触发）
输出：hookSpecificOutput（格式化的上下文字符串）

处理流程：
1. 调用 ContextBuilder.build()
2. ContextConfigLoader 加载配置（观察数量、类型过滤等）
3. TokenCalculator 计算 Token 预算
4. 按优先级组装上下文段：
   ├─ HeaderRenderer  → 项目标识和版本信息
   ├─ TimelineRenderer → 最近 N 条观察的时间线
   ├─ SummaryRenderer  → 最后一个会话摘要
   └─ FooterRenderer   → 使用提示
5. 输出格式化（Markdown 或 ANSI Color）
```

**配置项**：

| 配置 | 默认值 | 说明 |
|------|--------|------|
| `CONTEXT_OBSERVATIONS` | 50 | 注入的观察数量 |
| `CONTEXT_FULL_COUNT` | 5 | 完整详情的观察数 |
| `CONTEXT_SESSION_COUNT` | 10 | 包含的会话数 |
| `CONTEXT_OBSERVATION_TYPES` | 全部 | 观察类型过滤 |

#### 1.1.2 Session Init Handler（会话初始化）

**文件**：`src/cli/handlers/session-init.ts`

**职责**：UserPromptSubmit 时在数据库创建会话记录。

```
输入：{
  session_id: string,       // Claude Code 会话 ID
  user_prompt: string,       // 用户输入内容
  project: string            // 当前项目名称
}

处理流程：
1. 从 stdin 读取 JSON 格式的用户消息
2. 应用标签剥离（移除 <private> 和 <claude-mem-context>）
3. HTTP POST → Worker API /api/session/init
4. Worker 创建 sdk_sessions 记录：
   ├─ content_session_id = session_id
   ├─ memory_session_id = NULL（稍后捕获）
   ├─ status = 'active'
   └─ prompt_counter = 1
5. 返回 exit 0
```

#### 1.1.3 Observation Handler（观察记录）

**文件**：`src/cli/handlers/observation.ts`

**职责**：PostToolUse 时捕获工具调用结果并存储。

```
输入：{
  tool_name: string,        // 工具名称（Bash、Read、Write 等）
  tool_input: object,        // 工具输入参数
  tool_output: string,       // 工具输出结果
  session_id: string         // 当前会话 ID
}

处理流程：
1. 解析工具响应 JSON
2. 应用标签剥离（stripMemoryTagsFromJson）
3. HTTP POST → Worker API /api/session/observation
4. Worker 创建 pending_messages 记录（status=pending）
5. 后台处理：
   ├─ AI Agent 解析提取结构化数据
   │   ├─ title（标题）
   │   ├─ narrative（叙述）
   │   ├─ facts[]（事实列表）
   │   ├─ concepts[]（概念列表）
   │   ├─ files_read[]（读取的文件）
   │   └─ files_modified[]（修改的文件）
   ├─ 存储到 SQLite observations 表
   └─ 异步同步到 ChromaDB
6. 返回 exit 0
```

#### 1.1.4 Summarize Handler（摘要生成）

**文件**：`src/cli/handlers/summarize.ts`

**职责**：Stop 时生成会话摘要。

```
处理流程：
1. 收集当前会话所有观察记录
2. HTTP POST → Worker API /api/session/summarize
3. AI Agent 生成结构化摘要：
   ├─ request     → 本次会话的请求内容
   ├─ investigated → 调查了什么
   ├─ learned     → 学到了什么
   ├─ completed   → 完成了什么
   └─ next_steps  → 后续步骤
4. 存储到 session_summaries 表
5. 同步到 ChromaDB
```

#### 1.1.5 Session Complete Handler（会话完成）

**文件**：`src/cli/handlers/session-complete.ts`

**职责**：Stop 时标记会话为已完成。

```
处理流程：
1. HTTP POST → Worker API /api/session/complete
2. 更新 sdk_sessions.status = 'completed'
3. 设置 completed_at_epoch
4. 清理 pending_messages 中的残留消息
```

---

### 1.2 Worker Service 模块

#### 1.2.1 总体设计

**文件**：`src/services/worker-service.ts`（~1000 行）

**角色**：系统编排器，采用 Orchestrator 模式。

**状态机**：

```
                    ┌──────────┐
                    │  Created  │
                    └─────┬─────┘
                          │ listen()
                          ▼
                    ┌──────────┐
                    │ Listening │ ← 第一阶段完成
                    └─────┬─────┘
                          │ initializeBackground()
                          ▼
                    ┌──────────┐
                    │   Ready   │ ← 第二阶段完成
                    └─────┬─────┘
                          │ SIGTERM/SIGINT
                          ▼
                    ┌───────────┐
                    │ Shutting   │
                    │   Down    │
                    └─────┬─────┘
                          │
                          ▼
                    ┌──────────┐
                    │  Stopped  │
                    └──────────┘
```

#### 1.2.2 HTTP 路由设计

**路由注册**（`src/services/worker/http/routes/`）：

```typescript
// SearchRoutes.ts
GET  /api/search          → 搜索观察/摘要/提示
GET  /api/timeline        → 构建时间线上下文
GET  /api/observations    → 批量获取观察详情

// SessionRoutes.ts
POST /api/session/init     → 初始化会话
POST /api/session/observation → 记录观察
POST /api/session/summarize   → 生成摘要
POST /api/session/complete    → 完成会话
GET  /api/session/status      → 会话状态

// SettingsRoutes.ts
GET  /api/settings         → 获取当前设置
POST /api/settings         → 更新设置

// DataRoutes.ts
GET  /api/data/export      → 导出数据
POST /api/data/import      → 导入数据

// MemoryRoutes.ts
POST /api/memory/save      → 手动保存记忆

// LogsRoutes.ts
GET  /api/logs             → 获取日志

// ViewerRoutes.ts
GET  /                     → Viewer UI HTML
GET  /stream               → SSE 事件流
```

---

### 1.3 搜索子系统设计

#### 1.3.1 搜索编排器

**文件**：`src/services/worker/search/SearchOrchestrator.ts`

```
策略选择算法：

function selectStrategy(query: SearchQuery): SearchStrategy {
  if (!query.text && hasFilters(query)) {
    return new SQLiteSearchStrategy();   // 纯过滤
  }
  if (query.text && chromaAvailable) {
    return new HybridSearchStrategy();   // 语义 + 过滤
  }
  if (query.text) {
    return new SQLiteSearchStrategy();   // FTS5 全文
  }
  return new SQLiteSearchStrategy();     // 默认
}
```

#### 1.3.2 搜索策略接口

```typescript
abstract class SearchStrategy {
  abstract search(query: SearchQuery): Promise<SearchResult[]>;
  abstract getName(): string;
}
```

**ChromaSearchStrategy**：
```
1. 查询文本 → Chroma 向量搜索
2. 返回文档 ID + 相似度分数
3. 用 ID 批量查询 SQLite 获取完整数据
4. 按相似度分数排序
```

**SQLiteSearchStrategy**：
```
1. 构建 SQL WHERE 子句
2. 应用过滤器（日期、项目、类型）
3. FTS5 全文搜索（如果有查询文本）
4. 分页返回结果
```

**HybridSearchStrategy**：
```
1. Chroma 语义搜索获取候选 ID
2. SQLite 过滤器筛选候选集
3. 结果合并和重新排序
```

#### 1.3.3 过滤器链

```typescript
// 过滤器组合
class DateFilter    → dateStart / dateEnd 时间范围
class ProjectFilter → project 名称匹配
class TypeFilter    → observation type 枚举匹配
```

---

### 1.4 AI Agent 模块设计

#### 1.4.1 SDKAgent

**文件**：`src/services/worker/SDKAgent.ts`（~600 行）

```
事件驱动循环：

initialize(sessionId?)
  │
  ├─ 新会话 → createSession()
  └─ 恢复会话 → resumeSession(memorySessionId)
        │
        ▼
processMessage(content)
  │
  ├─ sendMessage(content)
  │     │
  │     ▼
  │   SDK 返回事件流
  │     ├─ text_delta → 累积响应
  │     ├─ tool_use → 工具调用（内部处理）
  │     └─ end → 处理完成
  │
  ├─ 提取 memorySessionId（从首次响应捕获）
  │
  └─ 返回结构化结果
        ├─ ParsedObservation（观察）
        └─ ParsedSummary（摘要）
```

**memorySessionId 延迟初始化**：
```
SDK 会话 ID 无法预先获取，必须从首次 SDK 响应中捕获。
因此采用 NULL 初始化 + 延迟填充策略：

CREATE → memory_session_id = NULL
FIRST RESPONSE → 捕获 SDK session ID → UPDATE memory_session_id
SUBSEQUENT → 使用 memory_session_id 恢复会话
```

#### 1.4.2 GeminiAgent

**文件**：`src/services/worker/GeminiAgent.ts`

```
回退 Agent，使用 Google Gemini API：
- 模型：gemini-2.5-flash-lite（默认）
- 速率限制：可配置
- 无会话恢复（每次独立调用）
```

#### 1.4.3 OpenRouterAgent

**文件**：`src/services/worker/OpenRouterAgent.ts`

```
OpenRouter 代理：
- 模型：xiaomi/mimo-v2-flash:free（默认）
- 通过 OpenRouter API 路由到多个提供者
- 免费层级支持
```

---

### 1.5 数据库模块设计

#### 1.5.1 SessionStore

**文件**：`src/services/sqlite/SessionStore.ts`（~2000 行）

**核心操作**：

```typescript
// 会话管理
createSession(params): Promise<SessionRecord>
getSession(contentSessionId): Promise<SessionRecord | null>
completeSession(contentSessionId): Promise<void>
updateMemorySessionId(contentSessionId, memorySessionId): Promise<void>

// 观察管理
storeObservation(obs: ParsedObservation): Promise<number>
getObservations(ids: number[]): Promise<ObservationRecord[]>
getRecentObservations(limit, project?, types?): Promise<ObservationRecord[]>

// 摘要管理
storeSummary(summary: ParsedSummary): Promise<number>
getLatestSummary(project?): Promise<SummaryRecord | null>

// 用户提示
storeUserPrompt(prompt): Promise<number>

// 队列管理
createPendingMessage(sessionDbId, type, data): Promise<number>
getPendingMessages(limit): Promise<PendingMessage[]>
updateMessageStatus(id, status): Promise<void>
```

#### 1.5.2 迁移系统

**文件**：`src/services/sqlite/migrations.ts`

```
迁移策略：
- 版本化迁移（v4 → v20）
- 幂等执行（检查是否已应用）
- 事务包裹（失败自动回滚）

关键迁移：
  v4:  初始 schema（sessions、observations）
  v8:  添加 user_prompts 表
  v10: 添加 session_summaries 表
  v12: 添加 pending_messages 表
  v14: 添加 FK 约束
  v16: 添加 timeline 视图
  v18: 添加观察元数据字段（concepts、facts）
  v20: 添加 discovery_tokens 字段
```

---

### 1.6 ChromaSync 模块设计

**文件**：`src/services/sync/ChromaSync.ts`（~1000 行）

```
同步策略：

initialize()
  │
  ├─ 检查平台（Windows 禁用）
  ├─ 连接 Chroma MCP 服务器
  └─ 初始化 Collection
        │
        ▼
syncAll()
  │
  ├─ 获取 Chroma 现有文档 ID
  ├─ 查询 SQLite 中缺失的记录
  └─ 批量上传（100 文档/批次）
        │
        ├─ 观察文档
        │   ├─ narrative（叙述文档）
        │   ├─ text（原始文本文档）
        │   └─ facts（每个事实一个文档）
        │
        ├─ 摘要文档
        │   ├─ request 文档
        │   ├─ investigated 文档
        │   ├─ learned 文档
        │   ├─ completed 文档
        │   └─ next_steps 文档
        │
        └─ 用户提示文档（单一文档）

文档 ID 格式：
  obs_{id}_narrative
  obs_{id}_text
  obs_{id}_fact_{index}
  sum_{id}_request
  sum_{id}_investigated
  ...
```

---

### 1.7 上下文构建模块设计

**文件**：`src/services/context/ContextBuilder.ts`

```
构建流程：

build(project?: string): Promise<string>
  │
  ├─ ContextConfigLoader.load()
  │   └─ 加载观察数量、类型过滤、Token 预算
  │
  ├─ ObservationCompiler.compile()
  │   ├─ 查询最近 N 条观察
  │   ├─ 按类型/概念过滤
  │   └─ 按时间排序
  │
  ├─ TokenCalculator.calculate()
  │   └─ 计算当前上下文的 Token 数
  │
  └─ 渲染各段落：
      ├─ HeaderRenderer.render()    → 项目信息、版本号
      ├─ TimelineRenderer.render()  → 时间线（最近观察）
      ├─ SummaryRenderer.render()   → 最后一个会话摘要
      └─ FooterRenderer.render()    → 使用提示、搜索指引

输出格式：
  ├─ MarkdownFormatter → Markdown 格式
  └─ ColorFormatter    → ANSI 彩色终端格式
```

---

### 1.8 隐私标签处理模块

**文件**：`src/utils/tag-stripping.ts`

```typescript
// 核心函数
export function stripMemoryTags(content: string): string
export function stripMemoryTagsFromJson(obj: any): any

// 处理逻辑
function stripTagsInternal(content: string): string {
  // ReDoS 防护
  const tagCount = countTags(content);
  if (tagCount > MAX_TAG_COUNT) {
    return content; // 拒绝处理，防止正则灾难
  }

  return content
    .replace(/<claude-mem-context>[\s\S]*?<\/claude-mem-context>/g, '')
    .replace(/<private>[\s\S]*?<\/private>/g, '')
    .trim();
}

// 递归 JSON 处理
function stripMemoryTagsFromJson(obj: any): any {
  if (typeof obj === 'string') return stripTagsInternal(obj);
  if (Array.isArray(obj)) return obj.map(stripMemoryTagsFromJson);
  if (typeof obj === 'object') {
    return Object.fromEntries(
      Object.entries(obj).map(([k, v]) => [k, stripMemoryTagsFromJson(v)])
    );
  }
  return obj;
}
```

---

### 1.9 Viewer UI 模块设计

#### 1.9.1 组件层次

```
App.tsx
├─ Header
│   ├─ Logo
│   ├─ ProjectFilter (Select)
│   ├─ ThemeToggle
│   ├─ SettingsButton → ContextSettingsModal
│   └─ GitHubStarsButton
│
├─ Feed
│   ├─ ObservationCard (type=observation)
│   │   ├─ 标题、叙述
│   │   ├─ 事实列表
│   │   ├─ 概念标签
│   │   └─ 文件列表
│   │
│   ├─ SummaryCard (type=summary)
│   │   ├─ request、investigated
│   │   ├─ learned、completed
│   │   └─ next_steps
│   │
│   ├─ PromptCard (type=prompt)
│   │   └─ 用户输入内容
│   │
│   └─ IntersectionObserver (无限滚动)
│
├─ LogsDrawer
│   └─ 控制台风格日志查看器
│
├─ ScrollToTop
└─ ErrorBoundary
```

#### 1.9.2 状态管理

```
React Hooks 架构（无外部状态库）：

useSSE(baseUrl)
  └─ 返回 { items, isConnected, processingStatus, queueDepth }

usePagination(baseUrl, project)
  └─ 返回 { data, loadMore, hasMore, isLoading }

useTheme()
  └─ 返回 { theme, setTheme }
  └─ localStorage 持久化

useSettings(baseUrl)
  └─ 返回 { settings, updateSettings }

useStats(baseUrl)
  └─ 返回 { totalObservations, totalSessions, ... }
```

#### 1.9.3 数据合并策略

```typescript
// App.tsx 中的合并逻辑
const mergedItems = useMemo(() => {
  if (projectFilter) {
    // 有项目过滤时：仅使用 API 分页数据
    return paginationData;
  }
  // 无过滤时：合并 SSE 直播数据 + 分页数据
  const combined = [...sseItems, ...paginationData];
  // 按 ID 去重
  const unique = Array.from(new Map(combined.map(i => [i.id, i])).values());
  // 按时间戳降序排序
  return unique.sort((a, b) => b.timestamp - a.timestamp);
}, [sseItems, paginationData, projectFilter]);
```

---

### 1.10 基础设施模块设计

#### 1.10.1 ProcessManager

**文件**：`src/services/infrastructure/ProcessManager.ts`

```
职责：
  ├─ Worker 进程的 fork/spawn
  ├─ PID 文件管理（写入/读取/清理）
  ├─ 信号转发（SIGTERM/SIGINT）
  └─ Windows 兼容性处理

PID 文件格式：
  {
    "pid": 12345,
    "port": 37777,
    "startedAt": "2026-02-08T10:00:00Z"
  }

Windows 特殊处理：
  - spawn 冷却期（防止快速重启竞态）
  - .exe 后缀检测
  - shell: true 选项
```

#### 1.10.2 HealthMonitor

**文件**：`src/services/infrastructure/HealthMonitor.ts`

```
健康检查机制：
  ├─ 端口可用性检测（TCP 连接测试）
  ├─ HTTP 健康端点（GET /health）
  ├─ 超时配置（默认 5 秒）
  └─ 重试逻辑（最多 3 次）
```

#### 1.10.3 GracefulShutdown

**文件**：`src/services/infrastructure/GracefulShutdown.ts`

```
关闭流程：
  1. 接收 SIGTERM/SIGINT
  2. 停止接受新请求
  3. 等待进行中的请求完成（超时 10 秒）
  4. 关闭 SSE 连接
  5. 关闭数据库连接
  6. 清理 PID 文件
  7. exit(0)
```

---

## 2. 错误处理设计

### 2.1 退出码策略

| 退出码 | 含义 | 使用场景 |
|--------|------|---------|
| 0 | 成功或可恢复错误 | 正常完成、Worker 启动失败但不阻塞 |
| 1 | 非阻塞错误 | stderr 显示给用户，Claude Code 继续 |
| 2 | 阻塞错误 | stderr 传递给 Claude 处理 |

### 2.2 消息队列重试

```
重试策略：
  pending → processing（开始处理）
    ├─ 成功 → completed
    └─ 失败 → failed
         ├─ 重试次数 < 3 → pending（重新入队）
         └─ 重试次数 ≥ 3 → abandoned（放弃）

Stale 消息恢复：
  Worker 重启时检查 processing 状态的消息
  ├─ processing_started_at > 5分钟前 → 重置为 pending
  └─ 防止消息永久卡在 processing 状态
```

---

## 3. 配置设计

### 3.1 设置层次

```
加载优先级（从高到低）：
  1. 环境变量（process.env.CLAUDE_MEM_*）
  2. 用户配置文件（~/.claude-mem/settings.json）
  3. 程序默认值（SettingsDefaultsManager.DEFAULTS）
```

### 3.2 完整配置项

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| `CLAUDE_MEM_PROVIDER` | `claude` | AI 提供者 |
| `CLAUDE_MEM_WORKER_PORT` | `37777` | Worker 端口 |
| `CLAUDE_MEM_WORKER_HOST` | `127.0.0.1` | Worker 绑定地址 |
| `CLAUDE_MEM_DATA_DIR` | `~/.claude-mem` | 数据目录 |
| `CLAUDE_MEM_CONTEXT_OBSERVATIONS` | `50` | 注入观察数 |
| `CLAUDE_MEM_CONTEXT_FULL_COUNT` | `5` | 完整详情数 |
| `CLAUDE_MEM_CONTEXT_SESSION_COUNT` | `10` | 会话数 |
| `CLAUDE_MEM_GEMINI_API_KEY` | `""` | Gemini API Key |
| `CLAUDE_MEM_GEMINI_MODEL` | `gemini-2.5-flash-lite` | Gemini 模型 |
| `CLAUDE_MEM_OPENROUTER_MODEL` | `xiaomi/mimo-v2-flash:free` | OpenRouter 模型 |
